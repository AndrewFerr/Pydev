/*
 * Created on Mar 27, 2006
 */
package org.python.pydev.editor.actions;


import org.eclipse.jface.action.IStatusLineManager;
import org.eclipse.jface.text.Assert;
import org.eclipse.jface.text.IRegion;
import org.eclipse.jface.text.ITextListener;
import org.eclipse.jface.text.ITextViewer;
import org.eclipse.jface.text.ITextViewerExtension;
import org.eclipse.jface.text.TextEvent;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.ISelectionProvider;
import org.eclipse.jface.viewers.SelectionChangedEvent;
import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.StyledText;
import org.eclipse.swt.custom.VerifyKeyListener;
import org.eclipse.swt.events.FocusEvent;
import org.eclipse.swt.events.FocusListener;
import org.eclipse.swt.events.MouseEvent;
import org.eclipse.swt.events.MouseListener;
import org.eclipse.swt.events.VerifyEvent;
import org.eclipse.swt.graphics.Color;
import org.eclipse.ui.texteditor.IStatusField;
import org.eclipse.ui.texteditor.IStatusFieldExtension;

/**
 * This action is supposed to be subclassed. It provides means to attach a listener to the editor and grab the input until
 * it is disabled (such as the incremental find: ctrl+j)
 * 
 * Reference implementation: 
 * 
 * class IncrementalFindTarget implements IFindReplaceTargetExtension, VerifyKeyListener, MouseListener, FocusListener, ISelectionChangedListener, ITextListener {

 * @author Fabio
 */
public class OfflineActionTarget implements VerifyKeyListener, MouseListener, FocusListener, ISelectionChangedListener, ITextListener {


    /** The string representing rendered tab */
    private final static String TAB= "<TAB>";
    
    /** The text viewer to operate on */
    private final ITextViewer fTextViewer;
    /** The status line manager for output */
    private final IStatusLineManager fStatusLine;
    /** The current find string */
    private StringBuffer fFindString= new StringBuffer();
    /** The position of the first upper case character, -1 if none */
    private int fCasePosition;
    /** The position of the last successful find */
    private int fCurrentIndex;
    /** A flag indicating if last find was successful */
    private boolean fFound;
    /**
     * A flag indicating if the last search was forward
     * @since 2.1
     */
    private boolean fForward= true;
    /** A flag indicating listeners are installed. */
    private boolean fInstalled;
    /**
     * A flag indicating that a search is currently active.
     * Used to ignore selection callbacks generated by the incremental search itself.
     * @since 2.1
     */
    private boolean fSearching;
    /**
     * The find status field.
     * @since 3.0
     */
    private IStatusField fStatusField;
    /**
     * Tells whether the status field implements
     * <code>IStatusFieldExtension</code>.
     * @see IStatusFieldExtension
     * @since 3.0
     */
    private boolean fIsStatusFieldExtension;



    /**
     * Creates an instance of an incremental find target.
     * @param viewer the text viewer to operate on
     * @param manager the status line manager for output
     */
    public OfflineActionTarget(ITextViewer viewer, IStatusLineManager manager) {
        Assert.isNotNull(viewer);
        Assert.isNotNull(manager);
        fTextViewer= viewer;
        fStatusLine= manager;
    }

    /*
     * @see IFindReplaceTargetExtension#beginSession()
     */
    public void beginSession() {
        fSearching= true;

        // Workaround since some accelerators get handled directly by the OS
        if (fInstalled) {
            updateStatus();
            fSearching= false;
            return;
        }

        fFindString.setLength(0);
        fCasePosition= -1;
        fFound= true;

        // clear initial selection
        StyledText text= fTextViewer.getTextWidget();
        if (text != null && !text.isDisposed()) {
            fCurrentIndex= text.getCaretOffset();
            text.setSelection(fCurrentIndex);
        } else {
            fCurrentIndex= 0;
        }

        install();

        // Set the mark
        if (fTextViewer instanceof ITextViewerExtension)
            ((ITextViewerExtension) fTextViewer).setMark(fCurrentIndex);

        updateStatus();

        fSearching= false;
    }

    /*
     * @see IFindReplaceTargetExtension#endSession()
     */
    public void endSession() {

        // will uninstall itself
    }

    /*
     * @see IFindReplaceTargetExtension#getScope()
     */
    public IRegion getScope() {
        return null;
    }

    /*
     * @see IFindReplaceTargetExtension#setGlobal(boolean)
     */
    public void setGlobal(boolean global) {
    }

    /*
     * @see IFindReplaceTargetExtension#setScope(IRegion)
     */
    public void setScope(IRegion scope) {
    }

    /*
     * @see IFindReplaceTargetExtension#setReplaceAllMode(boolean)
     */
    public void setReplaceAllMode(boolean replaceAll) {
    }

    /**
     * Installs this target. I.e. adds all required listeners.
     */
    private void install() {

        if (fInstalled)
            return;

        StyledText text= fTextViewer.getTextWidget();
        if (text == null)
            return;

        text.addMouseListener(this);
        text.addFocusListener(this);
        fTextViewer.addTextListener(this);

        ISelectionProvider selectionProvider= fTextViewer.getSelectionProvider();
        if (selectionProvider != null)
            selectionProvider.addSelectionChangedListener(this);

        if (fTextViewer instanceof ITextViewerExtension)
            ((ITextViewerExtension) fTextViewer).prependVerifyKeyListener(this);
        else
            text.addVerifyKeyListener(this);

        fInstalled= true;
    }

    /**
     * Uninstalls itself. I.e. removes all listeners installed in <code>install</code>.
     */
    private void uninstall() {

        fTextViewer.removeTextListener(this);

        ISelectionProvider selectionProvider= fTextViewer.getSelectionProvider();
        if (selectionProvider != null)
            selectionProvider.removeSelectionChangedListener(this);

        StyledText text= fTextViewer.getTextWidget();
        if (text != null) {
            text.removeMouseListener(this);
            text.removeFocusListener(this);
        }

        if (fTextViewer instanceof ITextViewerExtension) {
            ((ITextViewerExtension) fTextViewer).removeVerifyKeyListener(this);

        } else {
            if (text != null)
                text.removeVerifyKeyListener(this);
        }

        fInstalled= false;
    }

    /**
     * Updates the status line.
     * @since 2.1
     */
    private void updateStatus() {

        if (!fInstalled)
            return;

        String string= fFindString.toString();

        statusMessage(string);
//        statusError("Error");
    }

    /*
     * @see VerifyKeyListener#verifyKey(VerifyEvent)
     */
    public void verifyKey(VerifyEvent event) {

        if (!event.doit)
            return;

        fSearching= true;
        if (event.character == 0) {

            switch (event.keyCode) {

            // ALT, CTRL, ARROW_LEFT, ARROW_RIGHT == leave
            case SWT.ARROW_LEFT:
            case SWT.ARROW_RIGHT:
            case SWT.HOME:
            case SWT.END:
            case SWT.PAGE_DOWN:
            case SWT.PAGE_UP:
            case SWT.ARROW_DOWN:
            case SWT.ARROW_UP:
                leave();
                break;

            }

        // event.character != 0
        } else {

            switch (event.character) {

            // ESC, CR = quit
            case 0x1B:
            case 0x0D:
                leave();
                event.doit= false;
                break;

            // backspace    and delete
            case 0x08:
            case 0x7F:
                event.doit= false;
                break;

            default:
                if (event.stateMask == 0 || event.stateMask == SWT.SHIFT || event.stateMask == (SWT.ALT | SWT.CTRL)) { // SWT.ALT | SWT.CTRL covers AltGr (see bug 43049)
                    addCharSearch(event.character);
                    event.doit= false;
                }
                break;
            }
        }
        updateStatus();
        fSearching= false;
    }


    /**
     * Adds the given character to the search string and repeats the search with the last parameters.
     *
     * @param c the character to append to the search pattern
     * @return <code>true</code> the search found a match
     * @since 2.1
     */
    private boolean addCharSearch(char c) {
        // Add char to pattern
        if (fCasePosition == -1 && Character.isUpperCase(c) && Character.toLowerCase(c) != c)
            fCasePosition= fFindString.length();

        fFindString.append(c);
        String string= fFindString.toString();
        StyledText text= fTextViewer.getTextWidget();

        text.setRedraw(false);
//        int index= fTarget.findAndSelect(fCurrentIndex, string, fForward, fCasePosition != -1, false);
//
//        // Set the caret on the left if the search is reversed
//        if (!fForward) {
//            Point p= fTarget.getSelection();
//            text.setSelectionRange(p.x + p.y, -p.y);
//        }
        text.setRedraw(true);
//
//        // Take appropriate action
//        boolean found = (index != -1);
//        if (!found && fFound) {
//            text= fTextViewer.getTextWidget();
//            if (text != null && !text.isDisposed())
//                text.getDisplay().beep();
//        }

//        fFound= found;
        return true;
    }

    /**
     * Leaves this incremental search session.
     */
    private void leave() {
        statusClear();
        uninstall();
    }

    /*
     * @see ITextListener#textChanged(TextEvent)
     */
    public void textChanged(TextEvent event) {
        if (event.getDocumentEvent() != null)
            leave();
    }

    /*
     * @see MouseListener##mouseDoubleClick(MouseEvent)
     */
    public void mouseDoubleClick(MouseEvent e) {
        leave();
    }

    /*
     * @see MouseListener#mouseDown(org.eclipse.swt.events.MouseEvent)
     */
    public void mouseDown(MouseEvent e) {
        leave();
    }

    /*
     * @see MouseListener#mouseUp(org.eclipse.swt.events.MouseEvent)
     */
    public void mouseUp(MouseEvent e) {
        leave();
    }

    /*
     * @see FocusListener#focusGained(org.eclipse.swt.events.FocusEvent)
     */
    public void focusGained(FocusEvent e) {
        leave();
    }

    /*
     * @see FocusListener#focusLost(org.eclipse.swt.events.FocusEvent)
     */
    public void focusLost(FocusEvent e) {
        leave();
    }

    /**
     * Sets the given string as status message, clears the status error message.
     * @param string the status message
     */
    private void statusMessage(String string) {
        if (fStatusField != null) {
            if (fIsStatusFieldExtension) {
                ((IStatusFieldExtension)fStatusField).setErrorText(null);
                fStatusField.setText(escapeTabs(string));
                ((IStatusFieldExtension)fStatusField).setVisible(true);
                fStatusLine.update(true);
            } else {
                fStatusLine.setErrorMessage(null);
                fStatusField.setText(escapeTabs(string));
            }
        } else {
            fStatusLine.setErrorMessage(null);
            fStatusLine.setMessage(escapeTabs(string));
        }
    }

    /**
     * Sets the status error message, clears the status message.
     * @param string the status error message
     */
    private void statusError(String string) {
        if (fStatusField != null) {
            if (fIsStatusFieldExtension) {
                ((IStatusFieldExtension)fStatusField).setErrorText(escapeTabs(string));
                fStatusField.setText(""); //$NON-NLS-1$
                ((IStatusFieldExtension)fStatusField).setVisible(true);
                fStatusLine.update(true);
            } else {
                fStatusLine.setErrorMessage(escapeTabs(string));
                fStatusField.setText(""); //$NON-NLS-1$
            }
        } else {
            fStatusLine.setErrorMessage(escapeTabs(string));
            fStatusLine.setMessage(null);
        }
    }

    /**
     * Clears the status message and the status error message.
     */
    private void statusClear() {
        if (fStatusField != null) {
            if (fIsStatusFieldExtension) {
                fStatusField.setText(""); //$NON-NLS-1$
                ((IStatusFieldExtension)fStatusField).setErrorText(null);
                ((IStatusFieldExtension)fStatusField).setVisible(false);
                fStatusLine.update(true);
            } else {
                fStatusField.setText(""); //$NON-NLS-1$
                fStatusLine.setErrorMessage(null);
            }
        } else {
            fStatusLine.setErrorMessage(null);
            fStatusLine.setMessage(null);
        }
    }

    /**
     * Translates all tab characters into a proper status line presentation.
     * @param string the string in which to translate the tabs
     * @return the given string with all tab characters replace with a proper status line presentation
     */
    private String escapeTabs(String string) {
        StringBuffer buffer= new StringBuffer();

        int begin= 0;
        int end= string.indexOf('\t', begin);

        while (end >= 0) {
            buffer.append(string.substring(begin, end));
            buffer.append(TAB);
            begin= end + 1;
            end= string.indexOf('\t', begin);
        }
        buffer.append(string.substring(begin));

        return buffer.toString();
    }


    /*
     * @see IFindReplaceTargetExtension#setScopeHighlightColor(Color)
     */
    public void setScopeHighlightColor(Color color) {
    }

    /*
     * @see ISelectionChangedListener#selectionChanged(org.eclipse.jface.viewers.SelectionChangedEvent)
     * @since 2.1
     */
    public void selectionChanged(SelectionChangedEvent e) {
        System.out.println("selection changed:"+e);
    }

    /**
     * Sets the find status field for this incremental find target.
     *
     * @param statusField the status field
     * @since 3.0
     */
    void setStatusField(IStatusField statusField) {
        fStatusField= statusField;
        fIsStatusFieldExtension= fStatusField instanceof IStatusFieldExtension;
    }
}
