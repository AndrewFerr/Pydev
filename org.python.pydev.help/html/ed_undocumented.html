<h2>Undocumented features</h2>
<p>We've been slacking on documentation on code folding,
refactoring, and code completion. All these great features
have been implemented by fabioz. Instead of documentation,
here are some of the emails where he explains what he has
done:</p>

<i>Fabio writes:</i>
<xmp>
Refactoring:
	Completed:
	- Bicycle repair man (BRM) integration (support for rename and
      extract method). 
	- Added a view to show which files were affected by the last
      refactoring
	Missing:
	- Undo of the refactoring (it is supported by BRM but not
      integrated).
	- There are other refactorings that can be integrated. 
	- Only appearing on right click menu... Some keybindings could be
      used also.

Search:
	Using Bicycle repair man go to definition search on key F3. It is
used because our search was only on the current buffer (and that was really
annoying). 

Code completion:
	Basically, this was a rewrite from the python side of the code
completion. I think there are better ways to do it, but time is never
enough, so, code completion now works on:
		- import ...
		- from ... 
		- from a import ...
		- self.
		- any other token that we are able to get on the module
level, that is, variables initialized inside methods or other scopes are not
gotten (they weren't earlier either, so, that's not a retrocess).

	So, missing for this feature is:
		- Work on inner scopes: this would require some good work
with the python ast...
		- It still doesn't work on method parameters, but it could
be added without too much effort (I will do it as soon as I can, but I still
don't know when I will be able to do it - so, if anyone volunteers...).

Well, I think that's it... The bad part is that I didn't put it in pydev
help (if someone volunteers...)
</xmp>
And <i>Fabio writes some more:</i>
<xmp>
Refactor Examples (activates on right mouse click - there is usually a
keyboard key that emulates that):

On:

class C:
    def a(self):
        a = 2
        b = 3
        c = a+b #this should be refactored.
        return c
c = C()

Marking 'a+b' and making an extract method refactor for a method called
'plusMet' should give you:

class C:
    def a(self):
        a = 2
        b = 3
        c = self.plusMet(a, b) #this should be refactored.
        return c

    def plusMet(self, a, b):
        return a+b
c = C()



And with the same class, marking C (it must be the class definition) should
give you:
class G:
    def a(self):
        a = 2
        b = 3
        c = a+b #this should be refactored.
        return c
c = G()

Until now, extract method has given me no problems, but rename does not
always work... It has to scan all the PYTHONPATH and does not always find
all the references (and sometimes may have problems parsing some files
too...)

Methods or variables can be renamed too.

And as a helper, a Refactor Results View has been contributed. After any
refactoring it should show which files were changed, however, it only works
correctly if it is opened (if you do a refactor and open it later it won't
show the results - that's a bug).


-----------------------------------------------------------------

Code completion examples:

Imports completion goes for the sys.path, that is, if you go in python and:
import sys
print sys.path - those are the locations searched to get the imports tips.
Directories if they contain an __init__.py 
Files: .py, .py, .pyo, .pyd, .dll

So, if you go: (| Marks Ctrl+Space)
import |                    a list of the imports that can be gotten should
appear.
import comp|                completes imports that start with comp
import compiler.|           completes with compiler sub-modules and classes
import compiler.ast.|       completes with compiler.ast sub-modules and
classes
from compiler import |      completes with compiler sub-modules and classes
from compiler import ast.|  completes with compiler.ast sub-modules and
classes

Now for other completions:

If you have a file

from compiler import *

And just Ctrl+Space, it should appear all the globals, in this case all
compiler submodules and classes.

If you had just 

Import compiler 

Ctrl+Space would bring you '__builtins__' and 'compiler' suggestions


For class code completion:

Suppose you have:

import compiler 
class C(compiler.visitor.ASTVisitor):
    def __init__(self):
        self.| would bring you all the code available from this class.


compiler.| would bring all that is contained within the compiler module


There is a catch in this completion: as I rely on our ModelUtils to know in
which class I am, it only works correctly once it is parsed correctly (at
least once) - if this doesn't happen, you're getting an error such as 'name
self. Not defined', because as it can't determine it as a class in
ModelUtils, it tries to complete as if it was a simple token - this could be
worked with some kind of fast parser, just to determine in which class we
are...

Well, I think that's most of it...
</xmp>
<i>And even more Fabio</i>. I just asked him to fix a bug,
and he implemented another feature.
<xmp>
I added one more feature for the release: a Ctrl+1 advisor, to help on
assigning. E.g.

If you have a call in the main module, let's say:

C()| Ctrl+1 - bring a list of suggestions for assistants (it's still not
very complete, but it has already proved very usable for me)

Or if you have:

Class C:

	def a(self):
		self.newMethod()|  Ctrl+1 also brings some interesting
assistants.

It is not complete, but it works well for cases were it is well
used...eheheheh
</xmp>
<i>Beyond Fabio, we have Grig working on pyUnit integration. <i>
This is what he has to say about pyUnit menu item:
<xmp>
If you have a Python module that contains a TestCase subclass, 
it runs TextTestRunner on all the tests in that class and 
outputs the results on the console. The next version will '
have a view with a green/red bar, just as jUnit does.
</xmp>